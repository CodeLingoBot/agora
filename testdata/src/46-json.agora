ob := {}

ob.Stringify = func(src) {
	// Required here until closures are implemented...
  conv := import("conv")
  strings := import("strings")

  func ignored(key, val) {
  	return conv.Type(key) == "func" || conv.Type(val) == "func"
  }

  func stringify(val, quote) {
  	type := conv.Type(val)
  	if type == "string" || ((type == "number" || type == "bool") && quote) {
  		// TODO : more robust escape of quotes in the string...
			str := strings.Replace(val, `"`, `\"`)
  		return `"` + str + `"`
  	} else if type == "number" || type == "bool" {
  		return conv.String(val)
  	} else if type == "func" {
  		panic("cannot marshal a func to JSON")
  	} else if type != "object" {
  		return ""
  	} else if val.__toString {
			// An object, but it "knows" how to stringify itself
			return stringify(conv.String(val), true)
		}
  
  	// Finally, the object the "hard" way
  	ks := keys(val)
  	l := len(ks)
  	obj := "{"
  	for i := 0; i < l; i++ {
  		key := ks[i]
  		v := val[ks[i]]
  		if !ignored(key, v) {
				if obj != "{" {
					obj += ", "
				}
  			obj = strings.Concat(obj, stringify(key, true), ":", stringify(v, false))
  		}
  	}
		obj += "}"
  	return obj
  }

	return stringify(src, true)
}

ob.Parse = func(src) {
	// Required here until closures are implemented...
  conv := import("conv")
  strings := import("strings")

	i := 0
	ch := strings.ByteAt(src, i)
	
	func advance(expect) {
		if expect != "" && ch != expect {
			panic("expected " + expect + ", got " + ch)
		}
		i++
		ch = strings.ByteAt(src, i)
	}
	
	func skipWhitespace() {
		for ch == " " {
			advance(" ")
		}
	}

	func parseValue(reqQuotes) {
		quoted := ch == `"`
		if reqQuotes || quoted {
			advance(`"`)
		}
		val := ""
		// TODO : Detect escaped quotes
		for (quoted && ch != `"`) || (!quoted && (ch == "," || ch == "}" || ch == " " || ch == "]")) {
			val += ch
			advance("")
			if ch == "" {
				break
			}
		}
		if quoted {
			advance(`"`)
		}
		return val
	}
	
	func parseObject() {
		ob := {}
		advance("{")
		skipWhitespace()
		for ch != "}" {
			key := parseValue(true)
			skipWhitespace()
			advance(":")
			skipWhitespace()
			val := parseValue()
			ob[key] = val
			skipWhitespace()
		}
		advance("}")
		return ob
	}

	func parseArray() {
		a := {}
		i := 0
		advance("[")
		skipWhitespace()
		for ch != "]" {
			if i > 0 {
				advance(",")
				skipWhitespace()
			}
			val := parseValue()
			a[i] = val
			i++
			skipWhitespace()
		}
		advance("]")
		return a
	}
	
	o := nil
	skipWhitespace()
	if ch == "{" {
		o = parseObject()
	} else if ch == "[" {
		o = parseArray()
	} else {
		o = parseValue(true)
	}
	return o
}

return ob
