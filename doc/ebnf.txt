StmtList = { Statement ";" } .
Statement = SimpleStmt | ReturnStmt | YieldStmt | DebugStmt | IfStmt | ForStmt .

SimpleStmt = ExpressionStmt | IncDecStmt | Assignment | ShortVarDecl .
ExpressionStmt = Expression .
IncDecStmt = Expression ( "++" | "--" ) .
Assignment = ExpressionList assign_op ExpressionList .
ShortVarDecl = IdentifierList ":=" ExpressionList .

ReturnStmt = "return" [ Expression ] .

IfStmt = "if" Expression Block [ "else" ( IfStmt | Block ) ] .
Block = "{" StmtList "}" .

ForStmt = "for" RangeClause Block .
RangeClause = ( ExpressionList "=" | IdentifierList ":=" ) "range" Expression .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
Expression = UnaryExpr | Expression binary_op UnaryExpr .
UnaryExpr = PrimaryExpr | unary_op UnaryExpr .
PrimaryExpr = Operand |
							PrimaryExpr Selector |
							PrimaryExpr IndexSelector |
							PrimaryExpr Call .
Operand = Literal | OperandName | "(" Expression ")" .

Literal = BasicLit | CompositeLit | FunctionLit .
BasicLit = num_lit | string_lit | bool_lit .
CompositeLit = LiteralValue .
LiteralValue = "{" [ ElementList [ "," ] ] "}" .
ElementList = Element { "," Element } .
Element = Key ":" Value . // TODO : Eventually make key optional, implicit array index?
Key = FieldName | ElementIndex .
FiendName = identifier .
ElementIndex = Expression .
Value = Expression | LiteralValue .
FunctionLit = "func" Function .
Function = Signature FunctionBody .
FunctionBody = Block .
Signature = Parameters .
Parameters = "(" [ ParameterList [ "," ] ] ")" .
ParameterList = Parameter { "," Parameter } .
Parameter = identifier .

OperandName = identifier | QualifiedIdent .
QualifiedIdent = identifier "." identifier .

Selector = "." identifier .
IndexSelector = "[" Expression "]" .
Call = "(" [ ArgumentList [ "," ] ] ")" .
ArgumentList = ExpressionList .
